# -*- coding: utf-8 -*-
"""CS-412 Homework 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OUHMDS1qGhsndHaZ96tgJviTMEP0uIcp

# **CS412 - Machine Learning - 2022**
## Homework 1
100 pts


## **Goal**

The goal of this homework is three-fold:

*   Introduction to the machine learning experimental set up 
*   Gain experience with the Sklearn library
*   Learn which evaluation metric to choose in different scenarios

## **Dataset**
**JOB-A-THON - March 2022** Dataset contains the customer demographics and past activity with the bank. There is also the target label representing whether the customer will churn (stop working with the bank) or not.

Dataset is taken from: https://www.kaggle.com/datasets/gauravduttakiit/jobathon-march-2022

**Download the data from SuCourse**

## **Task**
Build a kNN and decision tree classifiers with the scikit library function calls to predict customer churn. Is_Churn is the target variable while the others will be used as features ('Age', 'Gender', 'Income', 'Balance', 'Vintage', 'Transaction_Status', 'Product_Holdings', 'Credit_Card', 'Credit_Category').

## **Software**: You may find the necessary function references here:
http://scikit-learn.org/stable/supervised_learning.html

## **Submission**: 
Name this notebook as: **YourName_Surname_hw1.ipynb** from the top left corner (e.g. for Özgür Can Seçkin -> Ozgur_Can_Seckin_hw1.ipynb)
Next, download this notebook as a *.ipynb document and upload* it on SuCourse. Also, click on the **"Share"** button on the top right hand side of the page and swicth from **"restricted" to "Anyone with the Link"** under the **"Get Link"** title. Then, **copy the link and paste it on the assignment's comment.**

If necessary, see the first recitation under Week 4 to get a tutorial on how to share your Colab link and how to download the .ipynb file.

## **Provide the Colab Link Here**:
https://colab.research.google.com/.....

##**1) Initialize**

*   First make a copy of the notebook given to you as a starter.

*   Make sure you choose Connect form upper right.

##**2) Load training dataset** *(5 pts)*

Read the csv file:
"""

# Load the Pandas libraries with alias 'pd' 
import pandas as pd 
from os.path import join
from google.colab import drive
# Read data
drive.mount("./drive", force_remount=True)

path_prefix = "./drive/My Drive"
filename = "train_hw1.csv"
df = pd.read_csv(join(path_prefix, filename))

"""##**3) Understanding the dataset** *(5 pts)*

There are alot of functions that can be used to know more about this dataset

- What is the shape of the training set (num of samples X number of attributes) ***(shape function can be used)***

- Get a quick summary of the data **(info can be used)**

- Display the first 5 rows from training dataset ***(head or sample functions can be used)***


Note: Understanding the features, possibly removing some features etc. is an important part in building an ML system.

"""

# print shape
print('Data Dimensionality: ',df.shape)
# print the summary for each column
print('Data Summary: ')
print(df.describe())
# print first 5 rows in your dataset
print('Head of Data: ')
print(df.head())

"""##**4) Seperate X and y Values** *(5 pts)*
First, you have to seperate X (features or independent variables) from y (target variable or dependent variables).

Note that our **dependent variable** is *'Is_Churn'* while the **independent variables** are: *'Age', 'Gender', 'Income', 'Balance', 'Vintage', 'Transaction_Status', 'Product_Holdings', 'Credit_Card', 'Credit_Category'*

*Hint: You can use drop method when defining X*
"""

# Drop ID column:
df = df.drop(columns=['ID'])

# Define X:
X = df.drop(columns=["Is_Churn"])

# Define y:
y = df.loc[:,"Is_Churn"]

"""##**5) Train - Test Split** *(5 pts)*
Since you will be going to apply cross validation, you do not need to use a validation set for now.
"""

from sklearn.model_selection import train_test_split

# Split 80-20

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2,random_state=42)

"""##**6) Transform Features Into Numerical Format** *(10 pts)*
You can take:
*   Gender information as a binary variable
*   Income and Credit_Category as ordinal variables

The dictionaries that you are going to use are given below:
"""

gender_map = {'Female':1, 'Male': 0}

Income_map = {'Less than 5L': 1, '5L - 10L': 2,'10L - 15L': 3,'More than 15L': 4}
              
Credit_Category_map = {'Poor': 1,'Average': 2,'Good': 3}

Product_Holdings_map = {'3+': 3}

# You can use replace method to replace the values on training and test sets:

X_train["Gender"] = X_train["Gender"].replace(gender_map)
X_test ["Gender"] = X_test ["Gender"].replace(gender_map)

X_train["Income"] = X_train["Income"].replace(Income_map)
X_test ["Income"] = X_test ["Income"].replace(Income_map)

X_train["Credit_Category"] = X_train["Credit_Category"].replace(Credit_Category_map)
X_test ["Credit_Category"] = X_test ["Credit_Category"].replace(Credit_Category_map)

X_train["Product_Holdings"] = X_train["Product_Holdings"].replace(Product_Holdings_map)
X_test ["Product_Holdings"] = X_test ["Product_Holdings"].replace(Product_Holdings_map)

"""##**7) Select the Best Evaluation Metric** *(25 pts)*
Since our bank is very risk averse, it tries to minimize the number of credits that we call "good" but actually are "bad".

![confusion_matrix.PNG](data:image/png;base64,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)

Which of the following performance metric should we employ in order to select the best model? (You can use the table above) Please write down the correct answer below (under **YOUR ANSWER HERE**) and explain your reasoning in one or two sentences.

1.   Accuracy
2.   Precision
3.   Recall

### YOUR ANSWER HERE:
We choose to use precision as a performance metric because Precision is the best metric for minimizing false positive. Since it has a False Positive as a denominator.

##**8) Train a decision tree classifier on train data and do model selection using the validation data** *(30 pts)*

* Set number of folds in cross validation as 5 *(5 pts)*
* Set scoring parameter to what you have determined in the last question as `scoring = '...'` *(5 pts)*
* Use grid_search to apply hyperparameter tuning on decision tree classifier with max_depth = 3, 5, 7, 9, 11 *(10 pts)*
* Plot the validation set performance metrics for these settings where x axis denotes the max_depth values and validation performance metrics are on y axis. *(10 pts)*
"""

from sklearn.model_selection import GridSearchCV
from sklearn.tree import DecisionTreeClassifier
import matplotlib.pyplot as plt
dtc=DecisionTreeClassifier()
# Train decision tree classifiers

max_depths = {'max_depth':[3,5,7,9,11]}

# loop over values of k for the Decision Tree classifier
grid = GridSearchCV(dtc,max_depths, cv=5,scoring='precision',verbose=1, refit=True)

grid_search = grid.fit(X_train, y_train)

# Plot errors
plt.plot(max_depths['max_depth'],grid_search.cv_results_['mean_test_score'])
plt.axhline(max(grid_search.cv_results_['mean_test_score']),color="red")
locs, labels =plt.yticks()
locs2= list(locs)

locs2.append(max(grid_search.cv_results_['mean_test_score']))
locs2= [round(num, 2) for num in locs2]
plt.yticks(locs2, locs2,fontsize=12)
plt.xticks(max_depths['max_depth'], max_depths['max_depth'],fontsize=12)
plt.grid(axis="both")
plt.xlabel('Max Depth', fontsize=12)
plt.ylabel('Mean Test Scores', fontsize=12)

plt.show()

"""##**9) Evaluate the Best Classifier on Test Set** *(15 pts)*

- Predict the labels of testing data. **Note that grid search cv function will return you the best estimator, so you can use directly the fitted function to make your predictions** and report the accuracy. 
"""

# test prediction using a decision tree with all default parameters and ..... min-split value 
predictions = grid_search.predict(X_test)

# Report your accuracy
from sklearn.metrics import accuracy_score, precision_score# you can find your scoring metric in this library

TestAccuracy = accuracy_score(y_test, predictions)
TestPrecisionScore = precision_score(y_test, predictions)
print("Testing Accuracy = %.5f%%" % (TestAccuracy * 100))
print("Testing Precision Score = %.5f%%" % (TestPrecisionScore * 100))

"""##**10) Submission**

Name this notebook as: **YourName_Surname_hw1.ipynb** from the top left corner (e.g. for Özgür Can Seçkin -> Ozgur_Can_Seckin_hw1.ipynb)
Next, download this notebook as a *.ipynb document and upload* it on SuCourse. Also, click on the **"Share"** button on the top right hand side of the page and swicth from **"restricted" to "Anyone with the Link"** under the **"Get Link"** title. Then, **copy the link and paste it on the assignment's comment.**

If necessary, see the first recitation under Week 4 to get a tutorial on how to share your Colab link and how to download the .ipynb file.

## Questions? 

You can and should ask all your Google Colab related questions under Forums  and feel free to answer/share your answer regarding Colab. 

You can also ask/answer about which functions to use and what libraries... 

However you should **not ask** about the core parts, that is what is validation/test, which one shd. have higher performance, what are your scores etc.
"""